import buildApp from "./main";
import { renderToString } from "vue/server-renderer";
import { basename } from "node:path";

export default (context, manifest) => {
  // console.log("context");
  // console.log(context);
  return new Promise((resolve) => {
    const { app, router } = buildApp();
    // console.log("App");
    // console.log(app);
    // console.log("Router");
    // console.log(router);
    // set the router to the desired URL before rendering
    (async (router, resolve) => {
      await router.push(context);
      await router.isReady();
      // renderToString(app);
      // passing SSR context object which will be available via useSSRContext()
      // @vitejs/plugin-vue injects code into a component's setup() that registers
      // itself on ctx.modules. After the render, ctx.modules would contain all the
      // components that have been instantiated during this render call.
      const ctx = {};
      const html = await renderToString(app, ctx);

      // the SSR manifest generated by Vite contains module -> chunk/asset mapping
      // which we can then use to determine what files need to be preloaded for this
      // request.
      const preloadLinks = renderPreloadLinks(ctx.modules, manifest);
      resolve([html, preloadLinks]);
    })(router, resolve);
    // set server-side router's location
    // router.push(context);
    // wait until router has resolve possible async components hooks
    // router.isReady(() => {
    //   const matchedComponents = router.currentRoute.value.matched;
    //   // no matched routes, reject with 404
    //   if (!matchedComponents.length) {
    //     return reject(new Error("404"));
    //   }

    //   // the Promise should resolve to the app instance so it can be rendered
    //   return resolve({ app, router });
    // }, reject);
  });
};

function renderPreloadLinks(modules, manifest) {
  let links = "";
  // console.log("Modules");
  // console.log(modules);
  // console.log("Manifest");
  // console.log(manifest);
  const seen = new Set();
  modules.forEach((id) => {
    const files = manifest[id];
    if (files) {
      files.forEach((file) => {
        if (!seen.has(file)) {
          seen.add(file);
          const filename = basename(file);
          if (manifest[filename]) {
            for (const depFile of manifest[filename]) {
              links += renderPreloadLink(depFile);
              seen.add(depFile);
            }
          }
          links += renderPreloadLink(file);
        }
      });
    }
  });
  return links;
}

function renderPreloadLink(file) {
  if (file.endsWith(".js")) {
    return `<link rel="modulepreload" crossorigin href="${file}">`;
  } else if (file.endsWith(".css")) {
    return `<link rel="stylesheet" href="${file}">`;
  } else if (file.endsWith(".woff")) {
    return ` <link rel="preload" href="${file}" as="font" type="font/woff" crossorigin>`;
  } else if (file.endsWith(".woff2")) {
    return ` <link rel="preload" href="${file}" as="font" type="font/woff2" crossorigin>`;
  } else if (file.endsWith(".gif")) {
    return ` <link rel="preload" href="${file}" as="image" type="image/gif">`;
  } else if (file.endsWith(".jpg") || file.endsWith(".jpeg")) {
    return ` <link rel="preload" href="${file}" as="image" type="image/jpeg">`;
  } else if (file.endsWith(".png")) {
    return ` <link rel="preload" href="${file}" as="image" type="image/png">`;
  } else {
    // TODO
    return "";
  }
}
